#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
//#include <stdmem.h>

//#define DEBUG

uint64_t count=0;

typedef uint64_t value;

// calculates base of the kernel of the linear form l restricted to the
//  subspace of all random generated by the independent random vectors
//  given by a pointer r to the first and a pointer e behind the last
// if one of the first m vectors is not in the kernel of l, move first
//  vector to the front, else to the back
// returns 0 if the linear form l is trivial when restricted,
//  otherwise 1 if vector moved to front, and otherwise -1
int32_t updateKernel(value *r, value *e, value l, value *i, value *m)
{
  value  v = 0;   // for storing first random not in kernel
  value *s = r;
  value  w = 0;
  value *j = i;
  // find first random vector not in kernel of the linear form l
  while ((s<e) && (!__builtin_parityll(l & *s))) {
    ++s;
    ++j;
  }
  if (s==e) // kernel stayed the same => probe useless
    return 0;
  if (m > s) { // image of kernel stays the same
    w = *j; // exchange values i and j point to
    *j = *i;
    *i = w;
    v = *s;  // store first random not in kernel as return value,
    *s = *r; //  and exchange it with the first vector in the kernel
    *r = v;
    while (++j, ++s<e) // ensure that remaining vectors are in kernel of l
      if (__builtin_parityll(l & *s)) {
        *s ^= v;  //  by moving random not in kernel into kernel
        *j ^= w;  // also update its image
      }
#ifdef DEBUG
    fflush(stdout);
    fprintf(stderr, "CASE -1: images of kernel stays the SAME\n");
    fflush(stderr);
#endif
    return -1;
  } else { // shrink image of kernel
    --e;
    i += e-r;
    w = *j; // exchange values i and j point to
    *j = *i;
    *i = w;
    v = *s;  // store first random not in kernel as return value,
    *s = *e; //  and exchange it with the first vector in the kernel
    *e = v;
    for (; s<e; ++s, ++j) // ensure that remaining vectors are in kernel of l
      if (__builtin_parityll(l & *s)) {
        *s ^= v;  //  by moving random not in kernel into kernel
        *j ^= w;  // also update its image
      }
#ifdef DEBUG
    fflush(stdout);
    fprintf(stderr, "CASE 1: images of kernel SHRINKS\n");
    fflush(stderr);
#endif
    return 1;
  }
}

// given a probing p of length q, the base b of the random of
//  dimension n, where its first q vectors are non-zero on the
//  corresponding probe and the remaining n-q being a base of
//  the kernel of the probing, it is checked if an alphabetically
//  smaller probing possesses the same kernel.
uint32_t newKernel(uint32_t *p, uint32_t q, value *b, uint32_t n, uint32_t u, uint32_t y, value *w)
{
  uint32_t  i, j;
  uint32_t  x;
  value    *c;
  value    *a, *z;
  u += y&1;      // correct u
  for (i=j=0; i<p[q-1]; ++i) {
    value v;
    if (i == p[j]) { // skip probes contained in probing p
      ++j; // only probes later than j can be replaced by higher i
      y &= (1<<(q-j))-1; // probe cannot replace first j probes added
      y |= 1<<(q-j);     // stop bit for loop
      continue;
    }
    v = w[i];
    a = b+u;     // points to first element of kernel base
    z = b+n-q+u; // points behind last element of kernel base
    for (c=a; c<z; ++c) // is current probe zero on kernel?
      if (__builtin_parityll(*c & v))
        break;
    if (c<z) // if not, it cannot replace a probe in probing p
      continue;
    for (x=y; x>1; x>>=1) // current probe linear dependent on prior ones?
      if (x&1) { // first non-kernel element was moved to front
        if (__builtin_parityll(*--a & v)) {   //  first j probes of p?
#ifdef DEBUG
          printf("EXTRA ");
#endif
          return 0;
        }
      } else { // first non-kernel element was moved to back
        if (__builtin_parityll(*z++ & v)) {   //  first j probes of p?
#ifdef DEBUG
          printf("EXTRA ");
#endif
          return 0;
        }
      }
    // check that a and z are correct
    if ((!j) && ((a != b) || (z != b+n))) {
      fprintf(stderr, "SOMETHING FISHY IN newKernel\n");
      exit(1);
    }
  }
  return 1;
}

value attack(value *k, uint32_t l, value s, uint32_t a, uint32_t b);
// Given the image of the kernel at the output
value check(value *d, uint32_t n, uint32_t t, uint32_t q)
{
  uint32_t  i, j, l;
  value    *b, s, res = 0;
  // initialize kernel as full space
  if (!(b = (value *) calloc(sizeof(value), t+1))) {
    fprintf(stderr, "ERROR: Cannot allocate %d byte of memory in check()\n", sizeof(value)*(t+1));
    exit(1);
  }
  for (i=0; i<=t; ++i)
    b[i] = (value) 1<<i;
  // find kernel
  for (i=0, l=t; i<n; ++i) {
    value tmp = d[i];
    value aux;
    for (j=0; j<=l; ++j) // find vector NOT in kernel
      if (__builtin_parityll(b[j] & tmp))
        break;
    if (j>l) // none found
      continue;
    aux = b[j];  // move first non-kernel element to end
    b[j] = b[l];
    b[l] = aux;
    for (; j<l; ++j) // and other non-kernel elements into kernel
      if (__builtin_parityll(b[j] & tmp))
        b[j] ^= aux;
    --l;
  } // l is index of last base element of kernel
#ifdef DEBUG
  {
    uint32_t j;
    printf("called check() with n=%d, t=%d, q=%d, l=%d\n", n, t, q, l+1);
    printf(" image of kernel is [%" PRIx64 "", d[0]);
    for (j=1; j<n; ++j)
      printf(" %" PRIx64 "", d[j]);
    printf("]\n");
    printf(" kernel of kernel is [%" PRIx64 "", b[0]);
    for (j=1; j<=l; ++j)
      printf(" %" PRIx64 "", b[j]);
    printf("]\n\n");
    fflush(stdout);
  }
#endif
  if (!l) {// minimal kernel (1,1...1,1) cannot be attacked
    free(b);
    return 0;
  }
  // check that or-sum of kernel is t+1
  for (i=0, s=0; i<=l; ++i)
    s |= b[i];
  if (__builtin_popcountll(s) != t+1) {
    uint32_t j;
    fprintf(stderr, "ERROR: ILLEGAL KERNEL IN CHECK()\n");
    fprintf(stderr, "t=%d, q=%d\n", t, q);
    fprintf(stderr, " [%" PRIx64 "", b[0]);
    for (j=1; j<=l; ++j)
      fprintf(stderr, " %" PRIx64 "", b[j]);
    fprintf(stderr, "]\n");
    fprintf(stderr, " [%" PRIx64 "", d[0]);
    for (j=1; j<=n; ++j)
      fprintf(stderr, " %" PRIx64 "", d[j]);
    fprintf(stderr, "]\n");
    fflush(stderr);
    exit(1);
  }
  // recursively find possible attacks
  res = attack(b, l, s, q, t-q);
  free(b);
  return res;
}

// check that no restriction gives a < HW(or-sum) <= b
value attack(value *k, uint32_t l, value s, uint32_t a, uint32_t b)
{
  value    x = s & (-s); // find lowest bit
  value    aux;
  value    t;
  uint32_t i;
  uint32_t c;
  for (i=0; i<=l; ++i) { // find first vector with bit set
    if (k[i] & x)
      break;
  }
  if (i>l) { // error, if no vector found
    uint32_t j;
    fprintf(stderr, "ERROR: WRONG OR-SUM IN ATTACK()\n");
    fprintf(stderr, " or-sum %" PRIx64 " with lowest bit %" PRIx64 " (i=%d, l=%d)\n", s, x, i, l);
    fprintf(stderr, " kernel of kernel is [%" PRIx64 "", k[0]);
    for (j=1; j<=l; ++j)
      fprintf(stderr, " %" PRIx64 "", k[j]);
    fprintf(stderr, "]\n");
    fflush(stderr);
    exit(1);
  }
  aux = k[i];  // move first non-kernel element to end
  k[i] = k[l];
  k[l] = aux;
  for (; i<l; ++i) // and other non-kernel elements into kernel
    if (__builtin_parityll(k[i] & x))
      k[i] ^= aux;
  // calculate or-sum of new kernel
  for (i=0, t=0; i<l; ++i)
    t |= k[i];
  c = __builtin_popcountll(t);
  // attack found?
  if ((a<c) && (c<=b)) {
#ifdef DEBUG
    uint32_t j;
    printf(" Found attack using [%" PRIx64 "", k[0]);
    for (j=1; j<l; ++j)
      printf(" %" PRIx64 "", k[j]);
    printf("]\n");
    fflush(stdout);
#endif
    return t; // attack found
  }
  aux = 0;
  if (s&t) { // if there are other intersections
    if (a<c) // if possible, restrict further for attack
      if (aux = attack(k, l-1, s&t, a, b)) // attack found
        return aux;
    // otherwise try next intersection
    aux = attack(k, l, s&t, a, b);
  }
  return aux;
}

// Given q probes in p
void dump(uint32_t *p, uint32_t q, value *r, uint32_t n, value *d, value *w)
{
  uint32_t  i;
  printf("Probing");
  for (i=0; i<q; ++i)
    printf(" %d", p[i]);
  if (q) {
    printf(" [%" PRIx64 "", w[p[0]]);
    for (i=1; i<q; ++i)
      printf(" %" PRIx64 "", w[p[i]]);
    printf("]");
  }
  printf("\n");
  printf(" Kernel =");
  for (i=0; i<n; ++i)
    printf(" %" PRIx64 "", (uint32_t) r[i]);
  printf("\n");
  printf(" Its image =");
  for (i=0; i<n; ++i)
    printf(" %" PRIx64 "", (uint32_t) d[i]);
  printf("\n");
  fflush(stdout);
}

int main(int argc, char *argv[])
{
  uint32_t  t;     // security level
  uint32_t  n;     // number of randoms
  uint32_t  i, j;  // auxiliary indices
  value     v;     // auxiliary value
  uint32_t *o;     // indices of output values
  uint32_t *p;     // indices of internal/direct probes
  uint32_t  q;     // number of internal/direct probes
  uint32_t *e;     // indices of external/indirect probes
  uint32_t  f;     // number of external/indirect probes
  value    *w;     // wiring coded as possible (internal/direct) probes
  FILE     *ifile; // input file containing wiring
  value    *r;     // array for storing random base with
                   //  the kernel of probing at the end
  value    *m;     // points to first vector NOT mapped to output zero
  value    *d;     // images of randoms in r at output
  int32_t   u = 0; // correction for update moving vectors also to back
  uint32_t  y = 0; // encodes if vectors were moved to front or back
  // step 1: read parameter file
  if (argc<2) {
    fprintf(stderr, "USAGE: %s filename\n", argv[0]);
    exit(1);
  }
  if (!(ifile = fopen(argv[1], "r"))) {
    fprintf(stderr, "ERROR: Could not open file %s for reading wiring\n", argv[1]);
    exit(1);
  }
  // step 1a: read security level and #randoms
  fscanf(ifile, "%d %d\n", &t, &n);
  printf("Security level t = %d using n = %d randoms:\n", t, n);
  if (!t) {
    fprintf(stderr, "ERROR: Security level 0 not supported\n");
    fclose(ifile);
    exit(1);
  }
  if (n>64) {
    fprintf(stderr, "ERROR: Only up to 64 randoms supported (%d were requested)\n", n);
    fclose(ifile);
    exit(1);
  }
  // step 1b: read and check outputs (must be increasing)
  if (!(o = calloc(t+1, sizeof(uint32_t)))) {
    fprintf(stderr, "ERROR: Could not reserve memory for %d outputs\n", t+1);
    fclose(ifile);
    exit(1);
  }
  for (i=0; i<t; ++i) // read outputs
    fscanf(ifile, "%d ", o+i);
  fscanf(ifile, "%d\n", o+t);
  for (i=0; i<t; ++i) // check that outputs increase
    if (o[i]>=o[i+1]) {
      fprintf(stderr, "ERROR: Outputs not in increasing order (%d vs. %d)\n", i, i+1);
      fclose(ifile);
      exit(1);
    }
  printf("Outputs at "); // output outputs
  for (i=0; i<t; ++i)
    printf("%d, ", o[i]);
  printf("%d.\n", o[t]);
  // step 1c: reserve memory for intermediate values
  if (!(w = calloc(o[t]+1, sizeof(value)))) {
    fprintf(stderr, "ERROR: Could not reserve memory for %d values\n", t+1);
    fclose(ifile);
    exit(1);
  }
  // step 1d: initialize randoms
  for (i=0; i<n; ++i)
    w[i] = (value) 1<<i;
  // step 1e: read and calculate wiring
  for (i=n; i<=o[t]; ++i) {
    uint32_t a, b;
    fscanf(ifile, "%d %d\n", &a, &b);
    if ((a<i) && (b<i) && (a>=0) && (b>=0)) { // legal wiring
      w[i] = w[a]^w[b];
    } else { // illegal wiring
      fprintf(stderr, "ERROR: Wiring for value %d asks for future value(s) (%d rsp. %d)\n", i, a, b);
      fclose(ifile);
      exit(1);
    }
  }
  printf("Wiring:\n");
  for (i=j=0; i<=o[t]; ++i)
    if (i!=o[j])
      printf("%2d: %" PRIx64 "\n", i, w[i]);
    else {
      ++j;
      printf("%2d: %" PRIx64 " (out)\n", i, w[i]);
    }
  // step 1f: release handle to file
  if (fclose(ifile)) {
    fprintf(stderr, "ERROR: Could not close file %s after reading wiring\n", argv[1]);
    exit(1);
  }
  // step 1g: check that output is random sharing of zero
  v=w[o[t]];
  for (i=0; i<t; ++i)
    v ^= w[o[i]];
  if (v) { // sum should be 0
    fprintf(stderr, "ERROR: Output is not a random sharing of zero\n");
    exit(1);
  }
  // step 2: prepare main loop
  // step 2a: initialize internal/direct probing (= set of probes)
  if ((t>>1) && !(p = calloc(t>>1, sizeof(uint32_t)))) {
    fprintf(stderr, "ERROR: Could not reserve memory for %d direct probes\n", t>>1);
    exit(1);
  }
  // step 2b: initialize external/indirect probing (= set of probes)
  if (!(e = calloc((t+1)>>1, sizeof(uint32_t)))) {
    fprintf(stderr, "ERROR: Could not reserve memory for %d external probes\n", t>>1);
    exit(1);
  }
  // step 2c: initialize memory for kernels
  if (!(r = calloc(n, sizeof(value)))) {
    fprintf(stderr, "ERROR: Could not reserve memory for %d values\n", n);
    exit(1);
  }
  for (i=0; i<n; ++i)
    r[i] = (value) 1<<i;
  // step 2e: initialize memory for images of kernel bases
  if (!(d = calloc(n, sizeof(value)))) {
    fprintf(stderr, "ERROR: Could not reserve memory for %d values\n", n);
    exit(1);
  }
  for (i=0; i<=t; ++i)
    for (j=0; j<n; ++j)
      d[j] += (value) __builtin_parityll(r[j] & w[o[i]])<<i;
  // step 2f: find complement of kernel of projection to outputs
  for (i=j=0; i<n; ++i) {
    if (v = d[i] & (-d[i])) { // lowest bit of d[i]
      uint32_t k;             // clear this bit in following values
      for (k=i+1; k<n; ++k)
        if (v & d[k]) {
          d[k] ^= d[i];
          r[k] ^= r[i];
        }
    } else { // if d[i] zero, move it to front
      d[i] = d[j];  // if d[i] is zero, exchange r[i] and r[j]
      d[j] = v;
      v = r[i];
      r[i] = r[j];
      r[j] = v;
      ++j;
    }
  }
  m = r+j; // r[j] is first basis vector NOT mapped to zero on output
  // step 3: generate and check all possible internal/direct probes
  q=0; // no probe yet
  do {
    int32_t z=0;
    // step 3a: update kernel and check solution
    // TODO: skip if earlier probing generated the same image of kernel
    // TODO: can test using space and dual space help better pruning
    if (q && !((z = updateKernel(r+u, r+n+u-q+1, w[p[q-1]], d+u, m)) &&
               (((q<<1)+2>=t) || newKernel(p, q, r, n, u, y+(z<0), w)))) { // new probe useful?
      if (z<=0) {
        ++y;
        ++u;
      }
#ifdef DEBUG
      printf("u = %d, q = %d, z = %d, y = %u\n", u, q, z, y);
#endif
      // if the kernel stays the same or the kernel was already checked
      //  before (as it was generated by an alphabetically smaller
      //  probing), this probing and all its extensions can be pruned.
      if ((((q+1)<<1)<t) && (p[q-1]<o[t])) { // if probing can be extended
        p[q] = o[t];  //  force pruning by appending highest probe
        ++q;          //  and incrementing count of probes
        y <<= 1;
      }
#ifdef DEBUG
      // interlude: print data of pruned branch
      printf("PRUNING! While probing");
      for (i=0; i<q; ++i)
        printf(" %d", p[i]);
      if (q) {
        printf(" [%" PRIx64 "", w[p[0]]);
        for (i=1; i<q; ++i)
          printf(" %" PRIx64 "", w[p[i]]);
        printf("]");
      }
      printf("\n");
      printf("  Kernel =");
      for (i=q-1; i<n; ++i)
        printf(" %" PRIx64 "", r[i]);
      printf("\n");
      printf("  Its image =");
      for (i=q-1; i<n; ++i)
        printf(" %" PRIx64 "", d[i]);
      printf("\n");
      fflush(stdout);
      // end of interlude: print data of pruned branch
#endif
    } else {
      if (q && (z<=0)) {
        ++y;
        ++u;
      }
      // step 3b: check if current probing is OK
#ifdef DEBUG
      printf("u = %d, y = %u\n", u, y);
      dump(p, q, r+u, n-q, d+u, w);
      dump(p, q, r, n, d, w);
#endif
      if ((z>0) && (f = check(d+j, n-q-j+u, t, q))) { // f>0 if attack found
        printf("FOUND ATTACK (with %d inner probes and %d outputs probed)!\n", q, t-q);
        dump(p, q, r+u, n-q, d+u, w);
        printf(" attack vector = %" PRIx64 "\n", f);
        for (i=0; f; ++i, f >>= 1)
          if (f&1)
            printf(" output %d (%" PRIx64 ")\n", o[i], w[o[i]]);
        fflush(stdout);
        exit(1);
      }
    }
    if (q<u) {
      fflush(stdout);
      fprintf(stderr, "\n\nERROR: q = %d < u = %d\n", q, u);
      fflush(stderr);
      exit(1);
    }
    ++count;
    if (count % 1000000 == 0) {
      printf(".");
      fflush(stdout);
    }
    // step 3b: switch to next probing
    if (!q) { // nothing probed yet, requires initialization of p and q
      if (t>>1) { // initialize single probe at first random
        p[0] = 0;
        q = 1;
        continue;
      } else // except for t<2 where internal probing is secure
        break;
    }
    if (p[q-1]==o[t]) { // if last value already maximal
      u -= y&1;
      y >>= 1;
      u -= y&1;
      y &= ~1;
      if (--q) // next probing is shorter (unless we are done)
        ++p[q-1];   //  with 2nd last probe incremented
    } else { // if last value not maximal
      if (((q+1)<<1)<t) { // if another internal/direct probe possible
        p[q] = p[q-1]+1; // add another probe
        y <<= 1;
        ++q;
      } else {      // if probing has maximal length
        ++p[q-1];   //  and increment last probe
        u -= y&1;
        y &= ~1;
      }
    }
  } while (q);
  printf("DONE\n");
#ifdef DEBUG
  dump(p, q, r, n, d, w);
#endif
  fflush(stdout);
  fflush(stderr);
  printf("\nNo Attack found! Total count = %" PRIu64 "\n", count);
  fflush(stdout);
  // step 3: clean up
  free(r);
  free(p);
  free(w);
  free(o);
  return 0;
}
